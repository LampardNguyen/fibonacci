! function () {
    angular.module("funcModule", ["commonModule", "commonDTA", "modelModule"]), angular.module("funcModule").service("$commonFunc", ["$DTA", "$commonModel", "$window", "$ionicFilterBar", "$q", "$tableName", "$tableName", function (e, n, o, s, i, t, t) {
        this.getNextIdOfTable = function (o, s) {
            e.getNextIdOfTable(n.db, o).then(function (e) {
                s(e)
            }, function (e) {
                console.log(e)
            })
        }, this.setView = function (e) {
            e != n.viewList[n.viewList.length - 1] && (n.viewList.push(e), n.view = e, o.location = e)
        }, this.getWordsOfLesson = function (o) {
            n.currentLesson.vocabulary = [], n.lessonList.push(n.currentLesson);
            var s = {
                lessonId: n.currentLesson.idOffline
            };
            e.selectTableWhere(n.db, t.LessonsWords, s).then(function (o) {
                _.each(o.rows, function (o) {
                    s = {
                        idOffline: o.wordId
                    }, e.selectTableWhere(n.db, t.Words, s).then(function (e) {
                        n.currentLesson.vocabulary.push(e.rows[0])
                    }, function (e) {
                        console.log(e)
                    })
                })
            }, function (e) {
                console.log(e)
            }), (o || angular.noop)()
        }, this.removeClass = function (o, s) {
            e.deleteTable(n, t.Classes, {
                idOffline: o.idOffline
            });
            var i = _.findIndex(n.classList, function (e) {
                return e.idOffline == o.idOffline
            });
            n.classList.splice(i, 1), 1 == s && n.loading.hide()
        }, this.checkIsOnline = function () {
            var e = i.defer(),
                n = Parse.Object.extend("Object"),
                o = new Parse.Query(n);
            return o.get(null, {
                success: function (e) {},
                error: function (n, o) {
                    e.resolve(o.code)
                }
            }), e.promise
        }
    }])
}();
! function () {
    angular.module("modelModule", []), angular.module("modelModule").factory("$commonModel", [function () {
        var s = {
            mainView: "#/main",
            view: "#/main",
            viewList: ["#/main"],
            classList: [],
            wordList: [],
            lessonList: [],
            lessonListOfClass: [],
            newWordList: [],
            newWordListTmp: [],
            words: [],
            classes: [],
            fibonacci: [],
            needExercisesCount: 0,
            doExercisesNeedList: [],
            maxCountLearn: 10,
            countWordsOfLesson: 5,
            rootDirectory: "file:///storage/emulated/0/",
            search: {}
        };
        return s
    }]), angular.module("modelModule").constant("$tableName", {
        Lessons: "Lessons",
        Classes: "Classes",
        Words: "Words",
        ClassesWords: "ClassesWords",
        ClassesLessons: "ClassesLessons",
        LessonsWords: "LessonsWords",
        Configs: "Configs",
        Fibonacci: "Fibonacci",
        Users: "Users"
    })
}();
! function () {
    angular.module("commonModule", []), angular.module("commonModule").factory("$commonSql", ["$q", function (e) {
        var n = {
            getwhereFromObjectWhere: function (e, n) {
                var r = "";
                for (var t in e) r += t + " = ? and ", n.push(e[t]);
                return r = r.substr(0, r.length - 4)
            },
            openDb: function () {
                var n = e.defer();
                return window.openDatabase ? (db = openDatabase("fibonaciDb", "1.0", "Offline local storage", 10485760), n.resolve(db)) : n.reject("system is not support web sql"), n.promise
            },
            createTable: function (n, r, t) {
                for (var o = e.defer(), i = t[0], c = 1; c < t.length; c++) i += ", " + t[c];
                return n.transaction(function (e) {
                    e.executeSql("CREATE TABLE IF NOT EXISTS " + r + " (" + i + " )", [], function (e, n) {
                        o.resolve(n)
                    }, function (e, n) {
                        console.log(r), console.log(n), o.reject(n)
                    })
                }), o.promise
            },
            insertData: function (n, r, t, o) {
                for (var i = o.length - 1; i >= 0; i--) o[i] !== !0 && o[i] !== !1 && null !== o[i] && (o[i] = o[i].toString());
                for (var c = e.defer(), u = t[0], a = "?", i = 1; i < t.length; i++) u += ", " + t[i], a += ", ?";
                var l = "INSERT INTO " + r + " (" + u + ") VALUES (" + a + ")";
                return n.transaction(function (e) {
                    e.executeSql(l, o, function (e, n) {
                        c.resolve(n)
                    }, function (e, n) {
                        c.reject(n)
                    })
                }), c.promise
            },
            updateData: function (n, r, t, o) {
                for (var i in t) t[i] !== !0 && t[i] !== !1 && null !== t[i] && (t[i] = t[i].toString());
                for (var i in o) o[i] !== !0 && o[i] !== !1 && null !== o[i] && (o[i] = o[i].toString());
                var c = [],
                    u = "",
                    a = "";
                for (var i in t) u += i + " = ?, ", c.push(t[i]);
                u = u.substr(0, u.length - 2), r = r.replace("objectValue", u), a = this.getwhereFromObjectWhere(o, c), r += a;
                var l = e.defer();
                return n.transaction(function (e) {
                    e.executeSql(r, c, function (e, n) {
                        l.resolve(n)
                    }, function (e, n) {
                        l.reject(n)
                    })
                }), l.promise
            },
            deleteData: function (n, r, t) {
                for (var o in t) t[o] !== !0 && t[o] !== !1 && null !== t[o] && (t[o] = t[o].toString());
                var i = [],
                    c = "";
                c = this.getwhereFromObjectWhere(t, i), r += c;
                var u = e.defer();
                return n.transaction(function (e) {
                    e.executeSql(r, i, function (e, n) {
                        u.resolve(n)
                    }, function (e, n) {
                        u.reject(n)
                    })
                }), u.promise
            },
            dropTable: function (n, r) {
                var t = e.defer();
                return n.transaction(function (e) {
                    e.executeSql(r, [], function (e, n) {
                        t.resolve(n)
                    }, function (e, n) {
                        t.reject(n)
                    })
                }), t.promise
            },
            executeQuery: function (n, r, t) {
                for (var o in t) t[o] !== !0 && t[o] !== !1 && null !== t[o] && (t[o] = t[o].toString());
                var i = [],
                    c = "";
                angular.isDefined(t) && null !== t && (c = this.getwhereFromObjectWhere(t, i)), r += c;
                var u = e.defer();
                return n.transaction(function (e) {
                    e.executeSql(r, i, function (e, n) {
                        u.resolve(n)
                    }, function (e, n) {
                        console.log(r), console.log(n), u.reject(n)
                    })
                }), u.promise
            },
            importData: function (n, r, t) {
                var o = e.defer();
                return n.transaction(function (e) {
                    r.forEach(function (n, i) {
                        for (var c = t[i].length - 1; c >= 0; c--) t[i][c] !== !0 && t[i][c] !== !1 && null !== t[i][c] && (t[i][c] = t[i][c].toString());
                        e.executeSql(n, t[i], function (e, n) {
                            i === r.length - 1 && o.resolve(n)
                        }, function (e, n) {
                            i === r.length - 1 && o.reject(n)
                        })
                    })
                }), o.promise
            },
            selectWords: function (n, r, t, o) {
                var i = [],
                    c = e.defer();
                return n.transaction(function (e) {
                    var n = "select * from Words where idOffline = ? and createdBy = ?";
                    angular.isDefined(t) && (n += " and isLearned = ?"), r.forEach(function (u, a) {
                        for (var l = u.length - 1; l >= 0; l--) u[l] !== !0 && u[l] !== !1 && null !== u[l] && (u[l] = u[l].toString());
                        u.push(o.currentUser.idOnline.toString()), angular.isDefined(t) && u.push("0"), e.executeSql(n, u, function (e, n) {
                            n.rows.length > 0 && i.push(n.rows[0]), a === r.length - 1 && c.resolve(i)
                        }, function (e, n) {
                            a === r.length - 1 && c.reject(n)
                        })
                    })
                }), c.promise
            }
        };
        return n
    }])
}();
! function () {
    angular.module("commonDTA", ["commonModule", "modelModule"]), angular.module("commonDTA", []).factory("$DTA", ["$q", "$commonSql", "$timeout", "$tableName", "$commonModel", function (e, n, r, s, t) {
        var o = {
            arrValue: [],
            arrSql: [],
            getArrayFromObject: function (e) {
                var n = [],
                    r = [];
                for (var s in e) n.push(s), r.push(e[s]);
                return {
                    arrColumn: n,
                    arrValue: r
                }
            },
            createTableNeeded: function (e) {
                n.createTable(e, "Lessons", ["idOffline NOT NULL", "name", "state", "learnStartDate", "relearnDate", "nextLearnDate", "nextFibonaci", "isLearned", "countLearn", "isSync", "created", "updated", "createdBy", "deletedBy", "isDeleted", "idOnline","classId", "CONSTRAINT pk_lessons PRIMARY KEY (idOffline)", "CONSTRAINT fk_lessons FOREIGN KEY (idOffline) REFERENCES ClassesLessons(lessonId) ON DELETE CASCADE"]), n.createTable(e, "Classes", ["userId", "idOffline NOT NULL", "name", "isSync", "created", "updated", "createdBy", "deletedBy", "isDeleted", "idOnline", "idLanguage", "CONSTRAINT pk_classes PRIMARY KEY (idOffline)"]), n.createTable(e, "Words", ["idOffline NOT NULL", "english", "vietnamese", "isLearned", "example", "isSync", "created", "updated", "createdBy", "deletedBy", "isDeleted", "idOnline","classId", "lessonid", "CONSTRAINT pk_words PRIMARY KEY (idOffline)", "CONSTRAINT fk_words FOREIGN KEY (idOffline) REFERENCES ClassesWords(wordId) ON DELETE CASCADE"]), n.createTable(e, "ClassesWords", ["classId NOT NULL", "wordId NOT NULL", "isSync", "created", "updated", "createdBy", "deletedBy", "isDeleted", "idOnline", "CONSTRAINT pk_words PRIMARY KEY (classId, wordId)", "CONSTRAINT fk_classes_words FOREIGN KEY (classId) REFERENCES Classes(idOffline)  ON DELETE CASCADE"]), n.createTable(e, "ClassesLessons", ["classId NOT NULL", "lessonId NOT NULL", "isSync", "created", "updated", "createdBy", "deletedBy", "isDeleted", "idOnline", "CONSTRAINT pk_classes_lessons PRIMARY KEY (classId, lessonId)", "CONSTRAINT fk_classes_lessons FOREIGN KEY (classId) REFERENCES Classes(idOffline)  ON DELETE CASCADE"]), n.createTable(e, "LessonsWords", ["lessonId NOT NULL", "wordId NOT NULL", "isSync", "created", "updated", "createdBy", "deletedBy", "isDeleted", "idOnline"]), n.createTable(e, "Configs", ["name NOT NULL", "value NOT NULL", "isSync", "created", "updated", "createdBy", "deletedBy", "isDeleted", "idOnline"]), n.createTable(e, "Fibonacci", ["number NOT NULL", "isSync", "created", "updated", "createdBy", "deletedBy", "isDeleted", "idOnline"]), n.createTable(e, "Users", ["uid NOT NULL", "idOffline NOT NULL", "username", "password", "email", "isSync", "created", "updated", "deletedBy", "isDeleted", "idOnline", "CONSTRAINT pk_users PRIMARY KEY (uid, idOffline)"]), n.executeQuery(e, "create trigger IF NOT EXISTS delete_classes before delete on Classes begin \tdelete from ClassesLessons where classId = OLD.idOffline; \tdelete from ClassesWords where classId = OLD.idOffline; end"), n.executeQuery(e, "create trigger IF NOT EXISTS delete_classes_lessons before delete on ClassesLessons begin \tdelete from Lessons where idOffline = OLD.lessonId; end"), n.executeQuery(e, "create trigger IF NOT EXISTS delete_classes_words before delete on ClassesWords begin \tdelete from Words where idOffline = OLD.wordId; \tdelete from LessonsWords where wordId = OLD.wordId; end"), n.executeQuery(e, "create trigger IF NOT EXISTS delete_lessons before delete on Lessons begin \tdelete from LessonsWords where lessonId = OLD.idOffline; end"), n.executeQuery(e, "create trigger IF NOT EXISTS insert_lessons_words after insert on LessonsWords begin \tupdate Words set isLearned = 1 where idOffline = NEW.wordId; end"), n.executeQuery(e, "create trigger IF NOT EXISTS delete_lessons_words before delete on LessonsWords begin \tupdate Words set isLearned = 0 where idOffline = OLD.wordId; end")
            },
            getMaxColOfTable: function (r, s, t, o) {
                var i = "select " + t + " from " + s + " ORDER BY " + t + " DESC LIMIT 1",
                    l = e.defer();
                return n.executeQuery(r, i).then(function (e) {
                    0 == e.rows.length ? l.resolve(null) : l.resolve(e.rows[0])
                }, function (e) {
                    l.reject(e)
                }), l.promise
            },
            getNextIdOfTable: function (r, s) {
                var t = "select idOffline from " + s + " ORDER BY CAST(idOffline AS INT) DESC LIMIT 1",
                    o = e.defer();
                return n.executeQuery(r, t).then(function (e) {
                    0 == e.rows.length ? o.resolve(0) : o.resolve(Number(e.rows[0].idOffline) + 1)
                }, function (e) {
                    o.reject(e)
                }), o.promise
            },
            insertTableLocal: function (e, r, s, t, o) {
                s.created = new Date(s.created).toISOString(), s.updated = new Date(s.updated).toISOString();
                var i = this.getArrayFromObject(s);
                n.insertData(e, r, i.arrColumn, i.arrValue).then(function (e) {
                    (t || angular.noop)(e)
                }, function (e) {
                    (o || angular.noop)(e)
                })
            },
            insertDataToTable: function (n, r, o) {
                var i = this,
                    l = e.defer();
                if (0 != t.isSyncToServer)
                    if ("Users" == r) {
                        var d = new Parse.User;
                        for (var a in o) o[a] !== !0 && o[a] !== !1 && null !== o[a] && (o[a] = o[a].toString());
                        i.executeParse(d, "signUp", o).then(function (e) {
                            o.idOnline = d.id, o.isSync = !0, o.created = d.createdAt.toISOString(), o.updated = d.updatedAt.toISOString(), i.insertTableLocal(n, r, o, function (e) {
                                l.resolve(e)
                            }, function (e) {
                                l.reject(e)
                            })
                        }, function (e) {
                            o.isSync = !1, i.insertTableLocal(n, r, o, function (e) {
                                l.resolve(e)
                            }, function (e) {
                                l.reject(e)
                            })
                        })
                    } else {
                        r != s.Fibonacci && (o.createdBy = t.currentUser.idOnline);
                        var c = Parse.Object.extend(r),
                            u = new c;
                        for (var a in o) o[a] !== !0 && o[a] !== !1 && null !== o[a] && (o[a] = o[a].toString());
                        i.executeParse(u, "save", o).then(function (e) {
                            o.idOnline = e.id, o.isSync = !0, o.created = e.createdAt.toISOString(), o.updated = e.updatedAt.toISOString(), i.insertTableLocal(n, r, o, function (e) {
                                l.resolve(e)
                            }, function (e) {
                                l.reject(e)
                            })
                        }, function (e) {
                            o.isSync = !1, i.insertTableLocal(n, r, o, function (e) {
                                l.resolve(e)
                            }, function (e) {
                                l.reject(e)
                            })
                        })
                    }
                else o.isSync = !0, i.insertTableLocal(n, r, o, function (e) {
                    l.resolve(e)
                }, function (e) {
                    l.reject(e)
                }), t.isSyncToServer = !0;
                return l.promise
            },
            selectTableById: function (r, o, i) {
                var l = {
                        idOffline: i
                    },
                    d = "select * from " + o + " where ";
                o != s.Users && o != s.Fibonacci ? l.createdBy = t.currentUser.idOnline : angular.isDefined(t.currentUser) && o == s.Users && (l.idOnline = t.currentUser.idOnline);
                var a = e.defer();
                return n.executeQuery(r, d, l).then(function (e) {
                    a.resolve(e)
                }, function (e) {
                    a.reject(e)
                }), a.promise
            },
            selectTableWhere: function (r, o, i) {
                var l = "select * from " + o + " where ";
                o != s.Users && o != s.Fibonacci ? i.createdBy = t.currentUser.idOnline : angular.isDefined(t.currentUser) && o == s.Users && (i.idOnline = t.currentUser.idOnline);
                var d = e.defer();
                return n.executeQuery(r, l, i).then(function (e) {
                    d.resolve(e)
                }, function (e) {
                    d.reject(e)
                }), d.promise
            },
            selectTableAll: function (r, o) {
                var i = "select * from " + o + " where ",
                    l = {};
                o != s.Users && o != s.Fibonacci ? l.createdBy = t.currentUser.idOnline : i = "select * from " + o;
                var d = e.defer();
                return n.executeQuery(r, i, l).then(function (e) {
                    d.resolve(e)
                }, function (e) {
                    d.reject(e)
                }), d.promise
            },
            updateTable: function (n, r, t, o) {
                var i = e.defer(),
                    l = this;
                if (r == s.Users) {
                    var d = Parse.User.current();
                    for (var a in t) t[a] !== !0 && t[a] !== !1 && null !== t[a] && (t[a] = t[a].toString()), d.set(a, t[a]);
                    d.save().then(function (e) {
                        return e.fetch()
                    }).then(function (e) {
                        console.log("Password changed", e), t.isSync = !0, t.updated = e.get("updatedAt").toISOString(), l.updateTableLocal(n, r, t, o).then(function (e) {
                            i.resolve(e)
                        }, function (e) {
                            console.log(e), i.reject(e)
                        })
                    }, function (e) {
                        console.log("Something went wrong", e), t.isSync = !1, l.updateTableLocal(n, r, t, o).then(function (e) {
                            i.resolve(e)
                        }, function (e) {
                            console.log(e), i.reject(e)
                        })
                    })
                } else l.selectTableWhere(n, r, o).then(function (e) {
                    var s = Parse.Object.extend(r),
                        d = new Parse.Query(s);
                    d.get(e.rows[0].idOnline, {
                        success: function (e) {
                            for (var s in t) t[s] !== !0 && t[s] !== !1 && null !== t[s] && (t[s] = t[s].toString()), e.set(s, t[s]);
                            e.save(null, {
                                success: function (e) {
                                    t.isSync = !0, t.updated = e.get("updatedAt").toISOString(), l.updateTableLocal(n, r, t, o).then(function (e) {
                                        i.resolve(e)
                                    }, function (e) {
                                        console.log(e), i.reject(e)
                                    })
                                },
                                error: function (e, n) {}
                            })
                        },
                        error: function (e, s) {
                            t.isSync = !1, l.updateTableLocal(n, r, t, o).then(function (e) {
                                i.resolve(e)
                            }, function (e) {
                                console.log(e), i.reject(e)
                            })
                        }
                    })
                }, function (e) {});
                return i.promise
            },
            updateTableLocal: function (r, o, i, l) {
                i.updated = new Date(i.updated).toISOString();
                var d = "update " + o + " set objectValue where ";
                o != s.Users ? l.createdBy = t.currentUser.idOnline : angular.isDefined(t.currentUser) && (l.idOnline = t.currentUser.idOnline);
                var a = e.defer();
                return n.updateData(r, d, i, l).then(function (e) {
                    a.resolve(e)
                }, function (e) {
                    console.log(e), a.reject(e)
                }), a.promise
            },
            deleteTableLocal: function (r, s, t) {
                var o = "delete from " + s + " where ",
                    i = e.defer();
                return n.deleteData(r.db, o, t).then(function (e) {
                    i.resolve(e)
                }, function (e) {
                    console.log(e), i.reject(e)
                }), i.promise
            },
            deleteTable: function (n, o, i) {
                var l = this;
                o != s.Users ? i.createdBy = t.currentUser.idOnline : angular.isDefined(t.currentUser) && (i.idOnline = t.currentUser.idOnline);
                var d = 0,
                    a = e.defer();
                return o == s.Classes && l.selectTableWhere(n.db, s.ClassesWords, {
                    classId: i.idOffline
                }).then(function (e) {
                    d = Math.ceil(e.rows.length / 1e3)
                }, function (e) {}), l.deleteTableLocal(n, o, i).then(function (e) {
                    a.resolve(e)
                }, function (e) {
                    console.log(e), a.reject(e)
                }), r(function () {
                    l.queryTable = function (e, r, s, t, o, i) {
                        var d = Parse.Object.extend(r),
                            a = new Parse.Query(d);
                        a.equalTo(s, t), a.equalTo("createdBy", n.currentUser.idOnline), a.limit(1e3), l.queryParse(a, e).then(function (e) {
                            (o || angular.noop)(e)
                        }, function (e) {
                            (i || angular.noop)(e)
                        })
                    }, o == s.Classes ? l.queryTable("first", s.Classes, "idOffline", i.idOffline, function (e) {
                        l.queryTable("find", s.ClassesLessons, "classId", e.get("idOffline"), function (e) {
                            e.forEach(function (e) {
                                l.queryTable("first", s.Lessons, "idOffline", e.get("lessonId"), function (e) {
                                    l.queryTable("find", s.LessonsWords, "lessonId", e.get("idOffline"), function (e) {
                                        Parse.Object.destroyAll(e)
                                    }, function (e) {
                                        console.log(e)
                                    }), e.destroy({})
                                }, function (e) {
                                    console.log(e)
                                })
                            }), Parse.Object.destroyAll(e)
                        }, function (e) {
                            console.log(e)
                        }), l.deleteClassWord = function (e, n) {
                            l.countDeleteClassWord > e || l.queryTable("find", s.ClassesWords, "classId", n.get("idOffline"), function (r) {
                                r.forEach(function (e) {
                                    l.queryTable("first", s.Words, "idOffline", e.get("wordId"), function (e) {
                                        e.destroy({})
                                    }, function (e) {
                                        console.log(e)
                                    })
                                }), Parse.Object.destroyAll(r), l.countDeleteClassWord += 1, l.deleteClassWord(e, n)
                            }, function (e) {
                                console.log(e)
                            })
                        }, l.countDeleteClassWord = 1, l.deleteClassWord(d, e), e.destroy({})
                    }, function (e) {
                        console.log(e)
                    }) : o == s.ClassesLessons ? (l.queryTable("first", s.Lessons, "idOffline", i.lessonId, function (e) {
                        l.queryTable("find", s.LessonsWords, "lessonId", e.get("idOffline"), function (e) {
                            e.forEach(function (e) {
                                l.queryTable("first", s.Words, "idOffline", e.get("wordId"), function (e) {
                                    e.set("isLearned", 0), e.save()
                                }, function (e) {
                                    console.log(e)
                                })
                            }), Parse.Object.destroyAll(e)
                        }, function (e) {
                            console.log(e)
                        }), e.destroy({})
                    }, function (e) {
                        console.log(e)
                    }), l.queryTable("first", s.ClassesLessons, "lessonId", i.lessonId, function (e) {
                        e.destroy({})
                    }, function (e) {
                        console.log(e)
                    })) : o == s.ClassesWords && (l.queryTable("first", s.ClassesWords, "wordId", i.wordId, function (e) {
                        e.destroy({})
                    }, function (e) {
                        console.log(e)
                    }), l.queryTable("first", s.Words, "idOffline", i.wordId, function (e) {
                        e.destroy({})
                    }, function (e) {
                        console.log(e)
                    }))
                }), a.promise
            },
            dropTable: function (r, s) {
                var t = "drop table " + s,
                    o = e.defer();
                return n.dropTable(r, t).then(function (e) {
                    o.resolve(e)
                }, function (e) {
                    console.log(e), o.reject(e)
                }), o.promise
            },
            importWordsClasses_words: function (r, s, o, i, l) {
                s.createdBy = t.currentUser.idOnline, o.createdBy = t.currentUser.idOnline;
                var d = this,
                    a = e.defer();
                d.arrSql.push("INSERT INTO ClassesWords (classId, wordId, isDeleted, deletedBy, createdBy, isSync) values (?, ?, ?, ?, ?, ?)"), d.arrSql.push("INSERT INTO Words (idOffline, english, vietnamese, example, isLearned, isDeleted, deletedBy, createdBy, isSync) values (?, ?, ?, ?, ?, ?, ?, ?, ?)");
                var c = [];
                for (var u in o) c.push(o[u]);
                d.arrValue.push(c), c = [];
                for (var u in s) c.push(s[u]);
                d.arrValue.push(c), angular.isUndefined(d.arrWords) && (d.arrWords = []);
                var f = angular.copy(s);
                delete f.isSync, d.arrWords.push(f), angular.isUndefined(d.arrClassesWords) && (d.arrClassesWords = []);
                var O = angular.copy(o);
                return delete O.isSync, d.arrClassesWords.push(O), l === i - 1 && (n.importData(r, d.arrSql, d.arrValue).then(function (e) {
                    d.updateWordWhenImport(), d.updateClassWordWhenImport(), a.resolve(e)
                }, function (e) {
                    console.log(e), a.reject(e)
                }), d.arrValue = [], d.arrSql = []), a.promise
            },
            updateWordWhenImport: function () {
                var e = this,
                    r = [];
                e.arrWords.forEach(function (e) {
                    var n = Parse.Object.extend(s.Words),
                        t = new n;
                    for (var o in e) e[o] !== !0 && e[o] !== !1 && null !== e[o] && (e[o] = e[o].toString()), t.set(o, e[o]);
                    r.push(t)
                }), e.executeParse(Parse.Object, "saveAll", r).then(function (r) {
                    var t = [],
                        o = [];
                    r.forEach(function (i, l) {
                        var d = {
                            idOnline: i.id,
                            isSync: !0,
                            created: i.createdAt.toISOString(),
                            updated: i.updatedAt.toISOString(),
                            idOffline: e.arrWords[l].idOffline
                        };
                        t.push("update " + s.Words + " set idOnline = ?, isSync = ?, created = ?, updated = ? where idOffline = ?");
                        var a = [];
                        for (var c in d) a.push(d[c]);
                        o.push(a), l == r.length - 1 && n.importData(db, t, o)
                    }), e.arrWords = []
                }, function (e) {
                    console.log(e)
                })
            },
            updateClassWordWhenImport: function () {
                var e = this,
                    r = [];
                e.arrClassesWords.forEach(function (e) {
                    var n = Parse.Object.extend(s.ClassesWords),
                        t = new n;
                    for (var o in e) e[o] !== !0 && e[o] !== !1 && null !== e[o] && (e[o] = e[o].toString()), t.set(o, e[o]);
                    r.push(t)
                }), e.executeParse(Parse.Object, "saveAll", r).then(function (r) {
                    var t = [],
                        o = [];
                    r.forEach(function (i, l) {
                        var d = {
                            idOnline: i.id,
                            isSync: !0,
                            created: i.createdAt.toISOString(),
                            updated: i.updatedAt.toISOString(),
                            classId: e.arrClassesWords[l].classId,
                            wordId: e.arrClassesWords[l].wordId
                        };
                        t.push("update " + s.ClassesWords + " set idOnline = ?, isSync = ?, created = ?, updated = ? where classId = ? and wordId = ?");
                        var a = [];
                        for (var c in d) a.push(d[c]);
                        o.push(a), l == r.length - 1 && n.importData(db, t, o)
                    }), e.arrClassesWords = []
                }, function (e) {
                    console.log(e)
                })
            },
            selectAllWordsOfClasses: function (r, s, o) {
                var i = e.defer();
                return n.selectWords(r, s, o, t).then(function (e) {
                    i.resolve(e)
                }, function (e) {
                    i.reject(e)
                }), i.promise
            },
            selectLessonsOfClasses: function (r, s) {
                var o = {},
                    i = "select Les.* from ClassesLessons as CL inner join Lessons as Les on CL.lessonId = Les.idOffline where ";
                o["CL.classId"] = s, o["Les.createdBy"] = t.currentUser.idOnline;
                var l = e.defer();
                return n.executeQuery(r, i, o).then(function (e) {
                    l.resolve(e)
                }, function (e) {
                    l.reject(e)
                }), l.promise
            },
            executeParse: function (n, r, s) {
                var t = e.defer();
                return n[r](s, {
                    success: function (e) {
                        t.resolve(e)
                    },
                    error: function (e) {
                        t.reject(e)
                    }
                }), t.promise
            },
            queryParse: function (n, r) {
                var s = e.defer();
                return n[r]({
                    success: function (e) {
                        s.resolve(e)
                    },
                    error: function (e) {
                        s.reject(e)
                    }
                }), s.promise
            }
        };
        return o
    }])
}();
